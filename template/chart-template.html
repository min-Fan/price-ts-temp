<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Linkol Price Chart</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          sans-serif;
        background: #ffffff;
        color: #000000;
      }

      .chart-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        gap: 8px;
        padding: 16px;
        padding-bottom: 8px !important;
        border: 1px solid #e5e7eb;
        background: #ffffff;
        border-radius: 12px;
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
        margin-top: 8px;
        width: 100%;
        max-width: 600px;
      }

      .title {
        font-size: 20px;
        font-weight: bold;
        text-align: center;
        line-height: 1.2;
      }

      .price {
        color: #3b82f6;
        font-weight: bold;
      }

      .subtitle {
        font-size: 14px;
        color: #6b7280;
        text-align: center;
        line-height: 1.4;
      }

      .chart-wrapper {
        width: 100%;
        height: 300px;
        position: relative;
      }

      .chart-canvas {
        width: 100%;
        height: 100%;
      }

      .chart-description {
        font-size: 12px;
        color: #6b7280;
        text-align: center;
        line-height: 1.4;
      }

      @media (min-width: 640px) {
        .chart-container {
          padding: 20px;
          border-radius: 16px;
        }

        .title {
          font-size: 24px;
        }

        .subtitle {
          font-size: 16px;
        }
      }
    </style>
  </head>
  <body>
    <div id="chart-container" class="chart-container">
      <h1 class="title">
        <span id="username"></span>'s tweet value:
        <span id="current-price" class="price"></span>
      </h1>
      <p class="subtitle" id="leading-text"></p>
      <div class="chart-wrapper">
        <canvas id="chart-canvas" class="chart-canvas"></canvas>
      </div>
      <p class="chart-description">price.linkol.ai</p>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
      // 图表渲染函数
      function renderChart(data) {
        const ctx = document.getElementById("chart-canvas").getContext("2d");

        // 设置画布尺寸
        const canvas = document.getElementById("chart-canvas");
        canvas.width = canvas.offsetWidth * 2;
        canvas.height = canvas.offsetHeight * 2;
        ctx.scale(2, 2);

        // 处理数据
        // const chartData = data.bins.map((price, index) => ({
        //   price: price,
        //   value: index === 0 ? 0 : data.data[index - 1] || 0,
        // }));
        const chartData = [
          { price: 100, value: 0 },
          { price: 900, value: 50 },
          { price: 1700, value: 230 },
          { price: 2500, value: 310 }, // 最高点（第四个点，正中间）
          { price: 3300, value: 230 },
          { price: 4100, value: 50 },
          { price: 4900, value: 20 },
          { price: 10000, value: 0 },
        ];

        // 创建图表
        const chart = new Chart(ctx, {
          type: "line",
          data: {
            labels: chartData.map((d) => d.price),
            datasets: [
              {
                label: "Price Distribution",
                data: chartData.map((d) => d.value),
                borderColor: "#3b82f6",
                backgroundColor: "rgba(59, 130, 246, 0.1)",
                borderWidth: 3,
                fill: true,
                tension: 0.4,
                pointRadius: 3,
                pointBackgroundColor: "#3b82f6",
                pointBorderColor: "#ffffff",
                pointBorderWidth: 2,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: false,
              },
              tooltip: {
                enabled: false,
              },
              customCanvasBackgroundColor: {
                color: "transparent",
              },
            },
            layout: {
              padding: {
                left: 20,
                right: 20,
                top: 50,
                bottom: 0,
              },
            },
            scales: {
              x: {
                type: "linear",
                display: true,
                title: {
                  display: false,
                },
                grid: {
                  display: false,
                },
                axisLine: {
                  display: false,
                },
                ticks: {
                  color: "#6b7280",
                  font: {
                    size: 12,
                  },
                },
              },
              y: {
                display: false,
                title: {
                  display: false,
                },
                grid: {
                  display: false,
                },
                ticks: {
                  display: false,
                },
              },
            },
            elements: {
              point: {
                hoverRadius: 6,
              },
            },
          },
          plugins: [
            {
              id: "avatarPlugin",
              afterRender: function (chart) {
                console.log("Avatar plugin executing...");
                const ctx = chart.ctx;
                const canvas = chart.canvas;

                if (
                  data.current_value !== undefined &&
                  data.kol &&
                  data.kol.profile_image_url
                ) {
                  console.log("Drawing avatar for:", data.kol.screen_name);
                  const xAxis = chart.scales.x;
                  console.log("xAxis", xAxis);
                  // 计算 current_value 在 bins 范围内的相对位置
                  const bins = chartData.map((d) => d.price);

                  // 找到 current_value 所在的区间，处理超出范围的情况
                  let lowerIndex = 0;
                  let upperIndex = 0;
                  let lowerBin = bins[0];
                  let upperBin = bins[1];
                  let positionValue;

                  // 检查是否超出范围
                  if (data.current_value < bins[0]) {
                    // 小于最小值，显示在最左边
                    positionValue = 0;
                    console.log(
                      "Current value below range, showing at leftmost position"
                    );
                  } else if (data.current_value > bins[bins.length - 1]) {
                    // 大于最大值，显示在最右边
                    positionValue = bins.length - 1;
                    console.log(
                      "Current value above range, showing at rightmost position"
                    );
                  } else {
                    // 在范围内，找到具体区间
                    for (let i = 0; i < bins.length - 1; i++) {
                      if (
                        data.current_value >= bins[i] &&
                        data.current_value <= bins[i + 1]
                      ) {
                        lowerIndex = i;
                        upperIndex = i + 1;
                        lowerBin = bins[i];
                        upperBin = bins[i + 1];
                        break;
                      }
                    }

                    // 在对数轴上计算位置
                    // 使用对数插值来获得更准确的位置
                    const logLower = Math.log(lowerBin);
                    const logUpper = Math.log(upperBin);
                    const logCurrent = Math.log(data.current_value);

                    // 计算在对数空间中的百分比
                    const logPercentage =
                      (logCurrent - logLower) / (logUpper - logLower);

                    // 使用对数插值计算实际位置
                    positionValue = Math.exp(
                      logLower + logPercentage * (logUpper - logLower)
                    );
                  }

                  console.log("Current value:", data.current_value);
                  console.log("Lower bin:", lowerBin, "Upper bin:", upperBin);
                  console.log(
                    "Lower index:",
                    lowerIndex,
                    "Upper index:",
                    upperIndex
                  );
                  console.log("Position value:", positionValue);

                  // 使用位置值获取像素坐标
                  let currentValueX = xAxis.getPixelForValue(positionValue);
                  console.log("Current value X position:", currentValueX);

                  // 绘制虚线
                  ctx.save();
                  ctx.strokeStyle = "#3b82f6";
                  ctx.setLineDash([5, 5]);
                  ctx.lineWidth = 2;
                  ctx.beginPath();
                  ctx.moveTo(currentValueX, 0);
                  // 使用 Y 轴的底部位置，这样虚线刚好到 X 轴线
                  ctx.lineTo(currentValueX, chart.scales.y.bottom);
                  ctx.stroke();
                  ctx.restore();

                  // 绘制头像背景圆圈
                  ctx.save();
                  ctx.beginPath();
                  ctx.arc(currentValueX, 20, 18, 0, 2 * Math.PI);
                  ctx.fillStyle = "#ffffff";
                  ctx.fill();
                  ctx.strokeStyle = "#3b82f6";
                  ctx.lineWidth = 2;
                  ctx.stroke();
                  ctx.restore();

                  // 绘制头像
                  const avatarImg = new Image();
                  avatarImg.crossOrigin = "anonymous";

                  // 创建Promise来等待图片加载完成
                  const avatarPromise = new Promise((resolve, reject) => {
                    avatarImg.onload = function () {
                      console.log("Avatar loaded, drawing...");
                      ctx.save();
                      ctx.beginPath();
                      ctx.arc(currentValueX, 20, 16, 0, 2 * Math.PI);
                      ctx.clip();
                      ctx.drawImage(avatarImg, currentValueX - 16, 4, 32, 32);
                      ctx.restore();
                      console.log("Avatar drawn successfully");
                      resolve();
                    };
                    avatarImg.onerror = function () {
                      console.error("Failed to load avatar image");
                      reject(new Error("Avatar image failed to load"));
                    };
                    avatarImg.src = data.kol.profile_image_url;
                  });

                  // 将Promise存储到图表实例中，供外部等待
                  chart.avatarLoadPromise = avatarPromise;

                  // 添加渲染完成标记
                  chart.avatarRendered = true;
                } else {
                  console.log("Missing data for avatar:", {
                    current_value: data.current_value,
                    kol: data.kol,
                    profile_image_url: data.kol?.profile_image_url,
                  });
                }
              },
            },
          ],
        });

        return chart;
      }

      // 更新页面内容
      function updateContent(data) {
        document.getElementById(
          "username"
        ).textContent = `@${data.kol.screen_name}`;
        document.getElementById(
          "current-price"
        ).textContent = `$${data.current_value}`;

        let leadingText = "AI ranks you above ";
        // if (data.leading_percentage >= 0 && data.leading_percentage < 30) {
        //   leadingText += "Bottom ";
        // } else if (
        //   data.leading_percentage > 30 &&
        //   data.leading_percentage < 70
        // ) {
        //   leadingText += "Middle ";
        // } else {
        //   leadingText += "Top ";
        // }
        leadingText += `${data.leading_percentage}% of KOLs`;

        document.getElementById("leading-text").textContent = leadingText;
      }

      // 导出为图片
      function exportToImage() {
        const container = document.getElementById("chart-container");
        html2canvas(container, {
          backgroundColor: "#ffffff",
          scale: 2,
          useCORS: true,
          allowTaint: true,
          logging: false,
        }).then((canvas) => {
          const link = document.createElement("a");
          link.download = "linkol-chart.png";
          link.href = canvas.toDataURL("image/png");
          link.click();
        });
      }

      // 全局函数，供外部调用
      window.renderLinkolChart = function (data) {
        updateContent(data);
        return renderChart(data);
      };

      // 等待头像加载完成的函数
      window.waitForAvatarLoad = function () {
        const chartCanvas = document.getElementById("chart-canvas");
        if (
          chartCanvas &&
          chartCanvas.chart &&
          chartCanvas.chart.avatarLoadPromise
        ) {
          return chartCanvas.chart.avatarLoadPromise.then(() => {
            // 等待一小段时间确保渲染完成
            return new Promise((resolve) => setTimeout(resolve, 500));
          });
        }
        return Promise.resolve();
      };

      window.exportChartImage = exportToImage;

      // 测试数据
      // updateContent({
      //   kol: {
      //     screen_name: "elonmusk",
      //     profile_image_url:
      //       "https://pbs.twimg.com/profile_images/1446320520480190472/WOO07ult_normal.jpg",
      //   },
      //   current_value: 3500,
      //   leading_percentage: 50,
      //   bins: [100, 1750, 3400, 5050, 6700, 8350, 10000],
      //   data: [249, 25, 5, 4, 0, 0],
      // });
      // renderChart({
      //   kol: {
      //     screen_name: "elonmusk",
      //     profile_image_url:
      //       "https://pbs.twimg.com/profile_images/1446320520480190472/WOO07ult_normal.jpg",
      //   },
      //   current_value: 3500,
      //   leading_percentage: 50,
      //   bins: [100, 1750, 3400, 5050, 6700, 8350, 10000],
      //   data: [249, 25, 5, 4, 0, 0],
      // });
    </script>
  </body>
</html>
